/*
-- =================================================================
--         ACADEEMIA MULTI-TENANT SCHEMA (IDEMPOTENT SCRIPT)
-- =================================================================
-- This script is idempotent, meaning it can be run multiple times
-- without causing errors. It will only create objects that do not
-- already exist.
-- =================================================================

-- =================================================================
-- 1. HELPER FUNCTIONS
-- Using CREATE OR REPLACE to ensure functions are always up-to-date.
-- =================================================================
CREATE OR REPLACE FUNCTION get_user_school_id()
RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN (SELECT school_id FROM public.user_profiles WHERE id = auth.uid());
END;
$$;

CREATE OR REPLACE FUNCTION get_user_role()
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN (SELECT role FROM public.user_profiles WHERE id = auth.uid());
END;
$$;

-- =================================================================
-- 2. CORE TABLES (USERS, SCHOOLS, ROLES)
-- Using CREATE TABLE IF NOT EXISTS to prevent errors on existing tables.
-- =================================================================

CREATE TABLE IF NOT EXISTS public.schools (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  name TEXT NOT NULL,
  official_name TEXT,
  email TEXT,
  mobile TEXT,
  address TEXT,
  city TEXT,
  state TEXT,
  currency_id BIGINT,
  system_logo_url TEXT,
  text_logo_url TEXT,
  printing_logo_url TEXT,
  report_card_logo_url TEXT
);
-- RLS: Using DROP/CREATE for policies to ensure they are correctly applied.
ALTER TABLE public.schools ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow all access to Super Admins" ON public.schools;
CREATE POLICY "Allow all access to Super Admins" ON public.schools FOR ALL USING (get_user_role() = 'Super Admin') WITH CHECK (get_user_role() = 'Super Admin');
DROP POLICY IF EXISTS "Allow school users to see their own school" ON public.schools;
CREATE POLICY "Allow school users to see their own school" ON public.schools FOR SELECT USING (id = get_user_school_id());


CREATE TABLE IF NOT EXISTS public.user_profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  school_id BIGINT REFERENCES public.schools(id) ON DELETE SET NULL,
  role TEXT NOT NULL,
  full_name TEXT,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view their own profile" ON public.user_profiles;
CREATE POLICY "Users can view their own profile" ON public.user_profiles FOR SELECT USING (auth.uid() = id);
DROP POLICY IF EXISTS "Users can update their own profile" ON public.user_profiles;
CREATE POLICY "Users can update their own profile" ON public.user_profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);
DROP POLICY IF EXISTS "Super Admins can manage all profiles" ON public.user_profiles;
CREATE POLICY "Super Admins can manage all profiles" ON public.user_profiles FOR ALL USING (get_user_role() = 'Super Admin') WITH CHECK (get_user_role() = 'Super Admin');


CREATE TABLE IF NOT EXISTS public.roles (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    school_id BIGINT NOT NULL REFERENCES public.schools(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    is_system_role BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(school_id, name)
);
ALTER TABLE public.roles ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow school users to manage their roles" ON public.roles;
CREATE POLICY "Allow school users to manage their roles" ON public.roles FOR ALL USING (school_id = get_user_school_id()) WITH CHECK (school_id = get_user_school_id());


CREATE TABLE IF NOT EXISTS public.role_permissions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    role_id BIGINT NOT NULL REFERENCES public.roles(id) ON DELETE CASCADE,
    permissions JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow access based on school affiliation" ON public.role_permissions;
CREATE POLICY "Allow access based on school affiliation" ON public.role_permissions FOR ALL USING (
    (SELECT school_id FROM public.roles WHERE id = role_id) = get_user_school_id()
) WITH CHECK (
    (SELECT school_id FROM public.roles WHERE id = role_id) = get_user_school_id()
);

-- =================================================================
-- 2.5 CURRENCY TABLE (GLOBAL and TENANT)
-- =================================================================
CREATE TABLE IF NOT EXISTS public.currencies (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    school_id BIGINT REFERENCES public.schools(id) ON DELETE CASCADE, -- Can be NULL for global currencies
    name TEXT NOT NULL,
    code TEXT NOT NULL UNIQUE,
    symbol TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
-- RLS: Allow public read access for store/pricing page, and admin access
ALTER TABLE public.currencies ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow public read access" ON public.currencies;
CREATE POLICY "Allow public read access" ON public.currencies FOR SELECT USING (true);
DROP POLICY IF EXISTS "Allow super admin full access" ON public.currencies;
CREATE POLICY "Allow super admin full access" ON public.currencies FOR ALL USING (get_user_role() = 'Super Admin') WITH CHECK (get_user_role() = 'Super Admin');
DROP POLICY IF EXISTS "Allow school users to manage their own currencies" ON public.currencies;
CREATE POLICY "Allow school users to manage their own currencies" ON public.currencies FOR ALL USING (school_id = get_user_school_id()) WITH CHECK (school_id = get_user_school_id());


-- =================================================================
-- 3. SCHOOL-SPECIFIC (TENANT) TABLES
-- =================================================================

-- Function to apply tenant RLS policies idempotently
CREATE OR REPLACE FUNCTION apply_tenant_rls(table_name TEXT)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY;', table_name);
  EXECUTE format('DROP POLICY IF EXISTS "Tenant Isolation Policy" ON public.%I;', table_name);
  EXECUTE format('CREATE POLICY "Tenant Isolation Policy" ON public.%I FOR ALL USING (school_id = get_user_school_id()) WITH CHECK (school_id = get_user_school_id());', table_name);
END;
$$;

-- ACADEMIC TABLES
CREATE TABLE IF NOT EXISTS public.sessions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    school_id BIGINT NOT NULL REFERENCES public.schools(id) ON DELETE CASCADE,
    session TEXT NOT NULL,
    status TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
SELECT apply_tenant_rls('sessions');

-- ADMISSION & RECEPTION TABLES
CREATE TABLE IF NOT EXISTS public.admission_enquiries (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    school_id BIGINT NOT NULL REFERENCES public.schools(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    mobile_no TEXT,
    guardian_details TEXT,
    reference TEXT,
    enquiry_date DATE,
    next_follow_up_date DATE,
    status TEXT,
    gender TEXT,
    date_of_birth DATE,
    previous_school TEXT,
    father_name TEXT,
    mother_name TEXT,
    email TEXT,
    address TEXT,
    no_of_child INT,
    assigned_to TEXT,
    response_type TEXT,
    response TEXT,
    note TEXT,
    class_applying_for TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
SELECT apply_tenant_rls('admission_enquiries');

CREATE TABLE IF NOT EXISTS public.postal_records (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    school_id BIGINT NOT NULL REFERENCES public.schools(id) ON DELETE CASCADE,
    type TEXT NOT NULL,
    reference_no TEXT,
    sender_title TEXT,
    receiver_title TEXT,
    address TEXT,
    note TEXT,
    date DATE,
    document_file_url TEXT,
    is_confidential BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
SELECT apply_tenant_rls('postal_records');

CREATE TABLE IF NOT EXISTS public.call_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    school_id BIGINT NOT NULL REFERENCES public.schools(id) ON DELETE CASCADE,
    call_type TEXT,
    calling_purpose TEXT,
    name TEXT NOT NULL,
    mobile_no TEXT,
    date DATE,
    start_time TIME,
    end_time TIME,
    follow_up_date DATE,
    note TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
SELECT apply_tenant_rls('call_logs');

CREATE TABLE IF NOT EXISTS public.visitor_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    school_id BIGINT NOT NULL REFERENCES public.schools(id) ON DELETE CASCADE,
    visiting_purpose TEXT,
    name TEXT NOT NULL,
    mobile_no TEXT,
    date DATE,
    entry_time TIME,
    exit_time TIME,
    number_of_visitors INT,
    id_number TEXT,
    token_pass TEXT,
    note TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
SELECT apply_tenant_rls('visitor_logs');

CREATE TABLE IF NOT EXISTS public.complaints (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    school_id BIGINT NOT NULL REFERENCES public.schools(id) ON DELETE CASCADE,
    complaint_type TEXT,
    assign_to TEXT,
    complainant_name TEXT NOT NULL,
    complainant_mobile_no TEXT,
    note TEXT,
    date DATE,
    document_file_url TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
SELECT apply_tenant_rls('complaints');

CREATE TABLE IF NOT EXISTS public.reception_configs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    school_id BIGINT NOT NULL REFERENCES public.schools(id) ON DELETE CASCADE,
    type TEXT NOT NULL,
    name TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(school_id, type, name)
);
SELECT apply_tenant_rls('reception_configs');

CREATE TABLE IF NOT EXISTS public.student_categories (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    school_id BIGINT NOT NULL REFERENCES public.schools(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(school_id, name)
);
SELECT apply_tenant_rls('student_categories');


-- =================================================================
-- 4. GLOBAL / SUPER ADMIN TABLES
-- =================================================================
CREATE OR REPLACE FUNCTION apply_super_admin_rls(table_name TEXT)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY;', table_name);
  EXECUTE format('DROP POLICY IF EXISTS "Super Admin Access Policy" ON public.%I;', table_name);
  EXECUTE format('CREATE POLICY "Super Admin Access Policy" ON public.%I FOR ALL USING (get_user_role() = ''Super Admin'') WITH CHECK (get_user_role() = ''Super Admin'');', table_name);
END;
$$;

CREATE TABLE IF NOT EXISTS public.plans (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    price_per_student NUMERIC(10, 2) DEFAULT 0,
    discount NUMERIC(10, 2) DEFAULT 0,
    period_type TEXT,
    period_value INT,
    features JSONB,
    is_recommended BOOLEAN DEFAULT FALSE,
    show_on_website BOOLEAN DEFAULT TRUE,
    status TEXT DEFAULT 'Active'
);
SELECT apply_super_admin_rls('plans');

CREATE TABLE IF NOT EXISTS public.subscriptions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    school_id BIGINT NOT NULL REFERENCES public.schools(id) ON DELETE CASCADE,
    plan_id BIGINT NOT NULL REFERENCES public.plans(id) ON DELETE RESTRICT,
    start_date DATE NOT NULL,
    expiry_date DATE,
    status TEXT NOT NULL,
    student_count INT,
    total_price NUMERIC(10, 2),
    created_at TIMESTAMPTZ DEFAULT NOW()
);
SELECT apply_super_admin_rls('subscriptions');

CREATE TABLE IF NOT EXISTS public.transactions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    school_id BIGINT NOT NULL REFERENCES public.schools(id) ON DELETE CASCADE,
    subscription_id BIGINT REFERENCES public.subscriptions(id),
    transaction_id TEXT,
    payment_method TEXT,
    amount NUMERIC(10, 2),
    currency TEXT,
    status TEXT,
    transaction_date TIMESTAMPTZ DEFAULT NOW()
);
SELECT apply_super_admin_rls('transactions');

-- =================================================================
-- 5. PUBLIC FORM SUBMISSION TABLES
-- =================================================================
CREATE TABLE IF NOT EXISTS public.contact_us_submissions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    name TEXT,
    email TEXT,
    subject TEXT,
    message TEXT,
    is_read BOOLEAN DEFAULT FALSE
);
ALTER TABLE public.contact_us_submissions ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow public form submissions" ON public.contact_us_submissions;
CREATE POLICY "Allow public form submissions" ON public.contact_us_submissions FOR INSERT TO anon WITH CHECK (true);
DROP POLICY IF EXISTS "Allow admins to manage" ON public.contact_us_submissions;
CREATE POLICY "Allow admins to manage" ON public.contact_us_submissions FOR ALL TO authenticated USING (get_user_role() = 'Super Admin');

CREATE TABLE IF NOT EXISTS public.demo_requests (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    name TEXT,
    email TEXT,
    phone TEXT,
    institution TEXT,
    role TEXT,
    interest TEXT,
    additional_info TEXT,
    status TEXT DEFAULT 'Pending'
);
ALTER TABLE public.demo_requests ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow public demo requests" ON public.demo_requests;
CREATE POLICY "Allow public demo requests" ON public.demo_requests FOR INSERT TO anon WITH CHECK (true);
DROP POLICY IF EXISTS "Allow admins to manage" ON public.demo_requests;
CREATE POLICY "Allow admins to manage" ON public.demo_requests FOR ALL TO authenticated USING (get_user_role() = 'Super Admin');

CREATE TABLE IF NOT EXISTS public.newsletter_subscribers (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    email TEXT NOT NULL UNIQUE,
    name TEXT,
    status TEXT DEFAULT 'Active',
    source TEXT
);
ALTER TABLE public.newsletter_subscribers ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow public newsletter subscriptions" ON public.newsletter_subscribers;
CREATE POLICY "Allow public newsletter subscriptions" ON public.newsletter_subscribers FOR INSERT TO anon WITH CHECK (true);
DROP POLICY IF EXISTS "Allow admins to manage" ON public.newsletter_subscribers;
CREATE POLICY "Allow admins to manage" ON public.newsletter_subscribers FOR ALL TO authenticated USING (get_user_role() = 'Super Admin');

-- =================================================================
-- 6. REAL-TIME PUBLICATION SETUP (Idempotent)
-- =================================================================
DO $$
BEGIN
   ALTER PUBLICATION supabase_realtime ADD TABLE public.contact_us_submissions;
EXCEPTION
   WHEN duplicate_object THEN
      RAISE NOTICE 'Table "contact_us_submissions" is already in the publication, skipping.';
END;
$$;

DO $$
BEGIN
   ALTER PUBLICATION supabase_realtime ADD TABLE public.demo_requests;
EXCEPTION
   WHEN duplicate_object THEN
      RAISE NOTICE 'Table "demo_requests" is already in the publication, skipping.';
END;
$$;

DO $$
BEGIN
   ALTER PUBLICATION supabase_realtime ADD TABLE public.newsletter_subscribers;
EXCEPTION
   WHEN duplicate_object THEN
      RAISE NOTICE 'Table "newsletter_subscribers" is already in the publication, skipping.';
END;
$$;


-- =================================================================
-- 7. STORAGE BUCKETS (Idempotent)
-- Create avatars bucket if it doesn't exist. Public read access.
-- NOTE: RLS policies for storage objects must be created via the Supabase Dashboard
-- under Authentication > Policies, as the 'postgres' user running this script
-- does not have permission to alter the 'storage.objects' table.
-- =================================================================
INSERT INTO storage.buckets (id, name, public)
VALUES ('avatars', 'avatars', true)
ON CONFLICT (id) DO NOTHING;

*/

import { supabase } from './supabase';

// --- NEW: USER PROFILE INTERFACE ---
export interface UserProfile {
  id: string; // UUID from auth.users
  school_id: number | null;
  role: string;
  full_name: string | null;
}

// --- DEFINE INTERFACES FOR OUR DATA ---
export interface Student {
  id: number;
  school_id: number;
  studentId: string;
  name: string;
  grade: number;
  parent: string;
  contact: string;
  photo: string;
}

export interface Course {
    id: number;
    school_id: number;
    courseId: string;
    name: string;
    teacher: string;
    students: number;
    subject: string;
}

export interface Lead {
    id: number;
    school_id: number;
    name: string;
    grade: string;
    contact: string;
    enquiryDate: string;
    status: 'New Enquiry' | 'Contacted' | 'Application Submitted' | 'Interview Scheduled' | 'Admitted';
}

export interface Task {
    id: number;
    school_id: number;
    title: string;
    assignedTo: string;
    dueDate: string;
    priority: 'High' | 'Medium' | 'Low';
    status: 'To Do' | 'In Progress' | 'Completed';
}

export interface Staff {
  id: number;
  school_id: number;
  staffId: string;
  name: string;
  role: string;
  department: string;
  email: string;
  phone: string;
  photo: string;
}

export interface LeaveRequest {
  id: number;
  school_id: number;
  staffId: string;
  staffName: string;
  leaveType: 'Annual' | 'Sick' | 'Maternity' | 'Unpaid';
  startDate: string;
  endDate: string;
  reason: string;
  status: 'Pending' | 'Approved' | 'Rejected';
}

// NOTE: Accounting module is company-wide, not school-specific in this model.
export interface Client {
  id: number;
  schoolName: string;
  plan: 'Starter' | 'Professional' | 'Enterprise';
  status: 'Active' | 'Canceled';
  joinDate: string;
  monthlyValue: number;
}

export interface Invoice {
  id: number;
  invoiceId: string;
  clientId: number; // Foreign key
  clientName: string;
  amount: number;
  issueDate: string;
  dueDate: string;
  status: 'Paid' | 'Due' | 'Overdue';
}

export interface Expense {
  id: number;
  category: 'Salaries' | 'Marketing' | 'Software' | 'Office Supplies';
  description: string;
  amount: number;
  date: string;
}

// --- INVENTORY INTERFACES ---
export interface Product {
    id: number;
    school_id: number;
    school: string;
    name: string;
    code: string;
    category: string;
    purchaseUnit: string;
    saleUnit: string;
    unitRatio: number;
    purchasePrice: number;
    salesPrice: number;
    remarks: string;
}

export interface Category {
    id: number;
    school_id: number;
    school: string;
    name: string;
}

export interface Store {
    id: number;
    school_id: number;
    school: string;
    name: string;
    code: string;
    mobile: string;
    address: string;
    description: string;
}

export interface Supplier {
    id: number;
    school_id: number;
    school: string;
    name: string;
    address: string;
    contact: string;
    email: string;
    company: string;
    products: string;
}

export interface Unit {
    id: number;
    school_id: number;
    school: string;
    name: string;
}

export interface Purchase {
    id: number;
    school_id: number;
    school: string;
    billNo: string;
    supplier: string;
    store: string;
    purchaseStatus: 'Received' | 'Ordered' | 'Pending';
    date: string;
    remarks: string;
}

export interface Sale {
    id: number;
    school_id: number;
    school: string;
    role: 'Student' | 'Parent' | 'Staff';
    saleTo: string;
    billNo: string;
    date: string;
    subTotal: number;
    discount: number;
    netPayable: number;
    receivedAmount: number;
    payVia: 'Cash' | 'Card' | 'Bank Transfer';
    remarks: string;
}

export interface Issue {
    id: number;
    school_id: number;
    school: string;
    role: 'Student' | 'Parent' | 'Staff';
    issueTo: string;
    dateOfIssue: string;
    dueDate: string;
    remark: string;
}

// --- CURRENCY AND UPDATED SCHOOL INTERFACES ---
export interface Currency {
    id: number;
    school_id: number | null;
    name: string;
    code: string;
    symbol: string;
}

export interface School {
    id: number;
    name: string;
    officialName: string;
    email: string;
    mobile: string;
    currency_id: number;
    city?: string;
    state?: string;
    address?: string;
    systemLogoUrl?: string | null;
    textLogoUrl?: string | null;
    printingLogoUrl?: string | null;
    reportCardLogoUrl?: string | null;
    currencies?: Currency; // For joined data
}

// --- SUBSCRIPTION MODULE INTERFACES ---
export interface Plan {
    id: number;
    name: string;
    pricePerStudent: number;
    discount: number;
    periodType: 'Days' | 'Monthly' | 'Termly' | 'Yearly' | 'Lifetime';
    periodValue: number;
    features: string[]; // JSONB stored as an array of strings
    isRecommended: boolean;
    showOnWebsite: boolean;
    status: 'Active' | 'Inactive';
}

export interface Subscription {
    id: number;
    school_id: number;
    plan_id: number;
    startDate: string;
    expiryDate: string | null;
    status: 'Active' | 'Expired' | 'Canceled' | 'Pending';
    studentCount: number;
    totalPrice: number;
    created_at: string;
    schools?: School;
    plans?: Plan;
}

export interface OfflinePaymentMethod {
    id: number;
    school_id: number;
    name: string;
    instructions: string;
    status: 'Active' | 'Inactive';
}

export interface Transaction {
    id: number;
    school_id: number;
    plan_id: number;
    transactionId: string;
    paymentMethod: string;
    amount: number;
    currency: string;
    status: 'Completed' | 'Pending' | 'Failed';
    transactionDate: string;
    schools?: School;
    plans?: Plan;
}

export interface CustomDomainRequest {
    id: number;
    school_id: number;
    requestedDomain: string;
    status: 'Pending' | 'Approved' | 'Rejected';
    requestDate: string;
    approvedDate: string | null;
    schools?: School;
}

// --- FORMS MANAGER INTERFACES ---
export interface ContactUsSubmission {
    id: number;
    created_at: string;
    name: string;
    email: string;
    subject: string;
    message: string;
    is_read: boolean;
}

export interface DemoRequest {
    id: number;
    created_at: string;
    name: string;
    email: string;
    phone?: string;
    institution: string;
    role: string;
    interest: string;
    additional_info?: string;
    status: 'Pending' | 'Contacted' | 'Closed';
}

export interface NewsletterSubscriber {
    id: number;
    created_at: string;
    email: string;
    name: string | null;
    status: 'Active' | 'Unsubscribed';
    source: string;
}

// --- SCHOOL SUBSCRIPTION FORM INTERFACE ---
export interface SchoolSubscriptionData {
    plan: Plan;
    studentCount: number;
    adminEmail: string;
    adminPassword: string;
    adminName: string;
    schoolName: string;
    schoolAddress: string;
    contactNumber: string;
    schoolLogoFile: File | null;
}

// --- INTEGRATIONS INTERFACES ---
export interface GoogleAnalyticsConfig {
  id: number;
  measurement_id: string | null;
  is_enabled: boolean;
}

export interface CalendlyConfig {
  id: number;
  scheduling_link: string | null;
  is_enabled: boolean;
}

export interface PusherConfig {
  id: number;
  app_id: string | null;
  key: string | null;
  secret: string | null;
  cluster: string | null;
  is_enabled: boolean;
}

// --- NEW: CORE DATA ACCESS REFACTOR ---

// Gets the full profile (role, school_id) of the currently logged-in user.
async function getUserProfile(): Promise<UserProfile | null> {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return null;

    const { data, error } = await supabase
        .from('user_profiles')
        .select('*')
        .eq('id', user.id)
        .single();
    
    if (error) {
        console.error("Error fetching user profile:", error);
        return null;
    }
    return data;
}

// --- Update User Profile Function ---
export async function updateUserProfile(userId: string, updates: { full_name: string }) {
    // 1. Update the public user_profiles table
    const { error: profileError } = await supabase
        .from('user_profiles')
        .update(updates)
        .eq('id', userId);

    if (profileError) {
        console.error("Error updating user_profiles table:", profileError);
        throw new Error(profileError.message);
    }
    
    // 2. Update the user metadata in the auth schema
    const { error: authError } = await supabase.auth.updateUser({
        data: { full_name: updates.full_name }
    });

    if (authError) {
        console.error("Error updating auth.users metadata:", authError);
        // Note: You might want to handle rollback logic here if the first update succeeded
        // but this one failed, to keep data consistent.
        throw new Error(authError.message);
    }
    
    // Both updates were successful
    console.log("User profile updated successfully in both tables.");
}

// --- NEW: Update User Avatar Function ---
export async function updateUserAvatar(userId: string, file: File) {
    if (!file) {
        throw new Error("No file provided for upload.");
    }

    const fileExt = file.name.split('.').pop();
    // Use a timestamp for the filename to avoid cache issues
    const fileName = `${Date.now()}.${fileExt}`;
    const filePath = `${userId}/${fileName}`;

    // 1. Upload the avatar to Supabase Storage
    const { error: uploadError } = await supabase.storage
        .from('avatars') // The bucket must be created in Supabase dashboard
        .upload(filePath, file, { upsert: false });

    if (uploadError) {
        console.error("Error uploading avatar:", uploadError);
        throw new Error(uploadError.message);
    }

    // 2. Get the public URL of the uploaded avatar
    const { data: urlData } = supabase.storage
        .from('avatars')
        .getPublicUrl(filePath);
    
    if (!urlData || !urlData.publicUrl) {
        throw new Error("Could not get public URL for avatar.");
    }

    const avatarUrl = urlData.publicUrl;

    // 3. Update the user metadata in the auth schema
    const { data, error: authError } = await supabase.auth.updateUser({
        data: { avatar_url: avatarUrl }
    });

    if (authError) {
        console.error("Error updating user avatar URL:", authError);
        throw new Error(authError.message);
    }
    
    // 4. Refresh the session to get the updated user metadata on the client
    await supabase.auth.refreshSession();

    return data.user;
}

// --- REFACTORED ASYNC DATA ACCESS FUNCTIONS (SCHOOL-SPECIFIC / MULTI-TENANT) ---
async function getData<T>(tableName: string, query: string = '*'): Promise<T[]> {
    const profile = await getUserProfile();
    // For school users, school_id is required. Super Admins might not have one.
    if (!profile || !profile.school_id) return [];

    const { data, error } = await supabase.from(tableName).select(query).eq('school_id', profile.school_id).order('id', { ascending: true });
    if (error) {
        console.error(`Error fetching from ${tableName}:`, error.message);
        return [];
    }
    return data as T[];
}

async function addData<T>(tableName: string, addData: Omit<T, 'id' | 'school_id'>) {
    const profile = await getUserProfile();
    if (!profile || !profile.school_id) {
        console.error(`Cannot add data to ${tableName}: user is not associated with a school.`);
        return;
    };
    
    const record = { ...addData, school_id: profile.school_id };
    const { error } = await supabase.from(tableName).insert(record);
    if(error) console.error(`Error adding to ${tableName}:`, error.message);
}

// Delete remains the same, as RLS policies at the DB level will prevent unauthorized deletions.
async function deleteData(tableName: string, id: number) {
    const { error } = await supabase.from(tableName).delete().eq('id', id);
    if (error) {
        console.error(`Error deleting from ${tableName}:`, error.message);
        throw error;
    }
}

// --- ASYNC DATA ACCESS FUNCTIONS (GLOBAL / SUPER ADMIN) ---
// These functions are for data not scoped by school_id, accessible only by Super Admins.
async function getGlobalData<T>(tableName: string, query: string = '*'): Promise<T[]> {
  try {
    const { data, error } = await supabase.from(tableName).select(query).order('id', { ascending: true });
    if (error) {
      console.error(`Error fetching from ${tableName}:`, error.message);
      return [];
    }
    return data as T[];
  } catch (err: any) {
    console.error(`Network error while fetching ${tableName}:`, err.message);
    return [];
  }
}

// Students
export const getStudents = (): Promise<Student[]> => getData<Student>('students');

// Courses
export const getCourses = (): Promise<Course[]> => getData<Course>('courses');

// Leads
export const getLeads = (): Promise<Lead[]> => getData<Lead>('leads');
export const addLead = (leadData: Omit<Lead, 'id' | 'school_id'>) => addData('leads', leadData);
export const updateLead = async (id: number, updates: Partial<Lead>) => {
    const { error } = await supabase.from('leads').update(updates).eq('id', id);
    if(error) console.error("Error updating lead:", error.message);
};

// Tasks
export const getTasks = (): Promise<Task[]> => getData<Task>('tasks');
export const addTask = (taskData: Omit<Task, 'id' | 'school_id'>) => addData('tasks', taskData);
export const updateTask = async (id: number, updates: Partial<Task>) => {
    const { error } = await supabase.from('tasks').update(updates).eq('id', id);
    if(error) console.error("Error updating task:", error.message);
};

// Staff
export const getStaff = (): Promise<Staff[]> => getData<Staff>('staff');

// Leave Requests
export const getLeaveRequests = (): Promise<LeaveRequest[]> => getData<LeaveRequest>('leave_requests');
export const updateLeaveRequestStatus = async (id: number, status: 'Approved' | 'Rejected') => {
    const { error } = await supabase.from('leave_requests').update({ status }).eq('id', id);
    if(error) console.error("Error updating leave request:", error.message);
};

// Accounting (Global)
export const getClients = (): Promise<Client[]> => getGlobalData<Client>('clients');
export const getInvoices = (): Promise<Invoice[]> => getGlobalData<Invoice>('invoices');
export const getExpenses = (): Promise<Expense[]> => getGlobalData<Expense>('expenses');

// --- INVENTORY FUNCTIONS ---
export const getProducts = (): Promise<Product[]> => getData<Product>('products');
export const addProduct = (data: Omit<Product, 'id' | 'school_id'>) => addData('products', data);
export const deleteProduct = (id: number) => deleteData('products', id);

export const getCategories = (): Promise<Category[]> => getData<Category>('categories');
export const addCategory = (data: Omit<Category, 'id' | 'school_id'>) => addData('categories', data);
export const deleteCategory = (id: number) => deleteData('categories', id);

export const getStores = (): Promise<Store[]> => getData<Store>('stores');
export const addStore = (data: Omit<Store, 'id' | 'school_id'>) => addData('stores', data);
export const deleteStore = (id: number) => deleteData('stores', id);

export const getSuppliers = (): Promise<Supplier[]> => getData<Supplier>('suppliers');
export const addSupplier = (data: Omit<Supplier, 'id' | 'school_id'>) => addData('suppliers', data);
export const deleteSupplier = (id: number) => deleteData('suppliers', id);

export const getUnits = (): Promise<Unit[]> => getData<Unit>('units');
export const addUnit = (data: Omit<Unit, 'id' | 'school_id'>) => addData('units', data);
export const deleteUnit = (id: number) => deleteData('units', id);

export const getPurchases = (): Promise<Purchase[]> => getData<Purchase>('purchases');
export const addPurchase = (data: Omit<Purchase, 'id' | 'school_id'>) => addData('purchases', data);
export const deletePurchase = (id: number) => deleteData('purchases', id);

export const getSales = (): Promise<Sale[]> => getData<Sale>('sales');
export const addSale = (data: Omit<Sale, 'id' | 'school_id'>) => addData('sales', data);
export const deleteSale = (id: number) => deleteData('sales', id);

export const getIssues = (): Promise<Issue[]> => getData<Issue>('issues');
export const addIssue = (data: Omit<Issue, 'id' | 'school_id'>) => addData('issues', data);
export const deleteIssue = (id: number) => deleteData('issues', id);

// --- SCHOOL & CURRENCY FUNCTIONS ---
export const getCurrencies = async (): Promise<Currency[]> => {
    const profile = await getUserProfile();
    // Super Admins can see all currencies from all schools
    if (profile?.role === 'Super Admin') {
        return getGlobalData<Currency>('currencies');
    }
    // School users see only their own currencies
    return getData<Currency>('currencies');
};
export const addCurrency = (data: Omit<Currency, 'id' | 'school_id'>) => addData('currencies', data);
export const deleteCurrency = (id: number) => deleteData('currencies', id);

// Public function for the store page (remains global)
export const getPublicCurrencies = async (): Promise<Currency[]> => {
    try {
        const { data, error } = await supabase.from('currencies').select('*');
        if (error) {
            console.error('Error fetching public currencies:', error.message);
            return [];
        }
        return data as Currency[];
    } catch (err: any) {
        console.error('Network error while fetching public currencies:', err.message);
        return [];
    }
};

// School management is a Super Admin task, so these functions are modified to not rely on the user's school_id
async function uploadSchoolLogo(file: File, schoolId: number, type: string): Promise<string | null> {
    if (!file) return null;
    const fileExt = file.name.split('.').pop();
    const fileName = `${type}-${Date.now()}.${fileExt}`;
    const filePath = `public/${schoolId}/${fileName}`;
    const { error: uploadError } = await supabase.storage.from('school_logos').upload(filePath, file, { upsert: true });

    if (uploadError) {
        console.error(`Error uploading ${type} logo:`, uploadError);
        return null;
    }

    const { data } = supabase.storage.from('school_logos').getPublicUrl(filePath);
    return data.publicUrl;
}

export const getSchools = (): Promise<School[]> => getGlobalData<School>('schools', 'id, name, officialName:official_name, email, mobile, currency_id, city, state, address, system_logo_url, text_logo_url, printing_logo_url, report_card_logo_url, currencies(*)');

export const getSchoolById = async (id: number): Promise<School | null> => {
    const { data, error } = await supabase
        .from('schools')
        .select('id, name')
        .eq('id', id)
        .single();
    
    if (error) {
        console.error(`Error fetching school with id ${id}:`, error.message);
        return null;
    }
    return data as School | null;
};

export const deleteSchool = (id: number) => deleteData('schools', id); // RLS will protect this for Super Admins

export const addSchool = async (schoolData: Omit<School, 'id' | 'systemLogoUrl' | 'textLogoUrl' | 'printingLogoUrl' | 'reportCardLogoUrl' | 'currencies'>, logos: { systemLogo?: File, textLogo?: File, printingLogo?: File, reportCardLogo?: File }) => {
    const record = {
        name: schoolData.name,
        official_name: schoolData.officialName,
        email: schoolData.email,
        mobile: schoolData.mobile,
        currency_id: schoolData.currency_id,
        city: schoolData.city,
        state: schoolData.state,
        address: schoolData.address,
    };
    
    const { data, error } = await supabase.from('schools').insert(record).select().single();
    if (error) throw error;
    if (!data) throw new Error("Failed to create school record.");

    const schoolId = data.id;
    const logoUrls: Record<string, string | null> = {};
    if (logos.systemLogo) logoUrls.system_logo_url = await uploadSchoolLogo(logos.systemLogo, schoolId, 'system');
    if (logos.textLogo) logoUrls.text_logo_url = await uploadSchoolLogo(logos.textLogo, schoolId, 'text');
    if (logos.printingLogo) logoUrls.printing_logo_url = await uploadSchoolLogo(logos.printingLogo, schoolId, 'printing');
    if (logos.reportCardLogo) logoUrls.report_card_logo_url = await uploadSchoolLogo(logos.reportCardLogo, schoolId, 'report_card');

    if (Object.keys(logoUrls).length > 0) {
        await supabase.from('schools').update(logoUrls).eq('id', schoolId);
    }
};

// --- SUBSCRIPTION MODULE FUNCTIONS (GLOBAL / SUPER ADMIN) ---
export const getPlans = (): Promise<Plan[]> => getGlobalData<Plan>('plans', '*, pricePerStudent:price_per_student, periodType:period_type, periodValue:period_value, isRecommended:is_recommended, showOnWebsite:show_on_website');
export const addPlan = (data: Omit<Plan, 'id'>) => supabase.from('plans').insert({ ...data, is_recommended: data.isRecommended, show_on_website: data.showOnWebsite });
export const deletePlan = (id: number) => deleteData('plans', id);
export const updatePlan = (id: number, data: Partial<Plan>) => supabase.from('plans').update(data).eq('id', id);

export const getSubscriptions = (): Promise<Subscription[]> => getGlobalData<Subscription>('subscriptions', '*, schools(*), plans(*)');
export const addSubscription = (data: Omit<Subscription, 'id' | 'created_at' | 'schools' | 'plans'>) => supabase.from('subscriptions').insert(data);

export const getOfflinePaymentMethods = (): Promise<OfflinePaymentMethod[]> => getData<OfflinePaymentMethod>('offline_payment_methods');
export const addOfflinePaymentMethod = (data: Omit<OfflinePaymentMethod, 'id' | 'school_id'>) => addData('offline_payment_methods', data);
export const deleteOfflinePaymentMethod = (id: number) => deleteData('offline_payment_methods', id);

export const getTransactions = (): Promise<Transaction[]> => getGlobalData<Transaction>('transactions', '*, schools(name), plans(name)');
export const addTransaction = (data: Omit<Transaction, 'id'>) => supabase.from('transactions').insert(data);

export const getCustomDomainRequests = (): Promise<CustomDomainRequest[]> => getGlobalData<CustomDomainRequest>('custom_domain_requests', '*, schools(name)');
export const addCustomDomainRequest = (data: Omit<CustomDomainRequest, 'id'>) => supabase.from('custom_domain_requests').insert(data);
export const updateCustomDomainRequestStatus = (id: number, status: 'Approved' | 'Rejected') => supabase.from('custom_domain_requests').update({ status, approved_date: status === 'Approved' ? new Date().toISOString() : null }).eq('id', id);

// --- FORMS MANAGER FUNCTIONS (PUBLIC/GLOBAL) ---
async function addPublicData(tableName: string, data: any) {
    const { error } = await supabase.from(tableName).insert(data);
    if (error) throw error;
}

async function getAllData<T>(tableName: string): Promise<T[]> {
    const { data, error } = await supabase.from(tableName).select('*').order('created_at', { ascending: false });
    if (error) {
        console.error(`Error fetching from ${tableName}:`, error.message);
        return [];
    }
    return data as T[];
}

export const addContactUsSubmission = (data: Omit<ContactUsSubmission, 'id' | 'created_at' | 'is_read'>) => addPublicData('contact_us_submissions', { ...data, is_read: false });
export const getContactUsSubmissions = (): Promise<ContactUsSubmission[]> => getAllData<ContactUsSubmission>('contact_us_submissions');
export const updateContactUsSubmission = (id: number, updates: Partial<ContactUsSubmission>) => updateFormSubmission('contact_us_submissions', id, updates);

export const addDemoRequest = (data: Omit<DemoRequest, 'id' | 'created_at' | 'status'>) => addPublicData('demo_requests', data);
export const getDemoRequests = (): Promise<DemoRequest[]> => getAllData<DemoRequest>('demo_requests');
export const updateDemoRequest = (id: number, updates: Partial<DemoRequest>) => updateFormSubmission('demo_requests', id, updates);

export const addNewsletterSubscriber = (data: Pick<NewsletterSubscriber, 'email' | 'name'>) => addPublicData('newsletter_subscribers', { email: data.email, name: data.name, status: 'Active', source: 'Website' });
export const getNewsletterSubscribers = (): Promise<NewsletterSubscriber[]> => getAllData<NewsletterSubscriber>('newsletter_subscribers');
export const updateNewsletterSubscriber = (id: number, updates: Partial<NewsletterSubscriber>) => updateFormSubmission('newsletter_subscribers', id, updates);

export const deleteFormSubmission = (tableName: string, id: number) => deleteData(tableName, id);
export const updateFormSubmission = async (tableName: string, id: number, updates: object) => {
    const snakeCaseUpdates = Object.entries(updates).reduce((acc, [key, value]) => {
        const snakeKey = key.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
        acc[snakeKey] = value;
        return acc;
    }, {} as Record<string, any>);
    await supabase.from(tableName).update(snakeCaseUpdates).eq('id', id);
};

export const createSchoolAndSubscription = async (data: SchoolSubscriptionData) => {
    // This function is complex and should be handled by a Super Admin panel or an Edge Function for security.
    // The current implementation allows any user to create a new user and school, which is a security risk.
    // For now, it's left as is but should be refactored into a secure administrative process.
    console.warn("createSchoolAndSubscription is being called from the client-side and should be moved to a secure environment.");

    // The rest of the function...
    const { data: { user }, error: signUpError } = await supabase.auth.signUp({ email: data.adminEmail, password: data.adminPassword, options: { data: { full_name: data.adminName } } });
    if (signUpError) throw signUpError;
    if (!user) throw new Error("Registration failed.");
    
    // Create profile
    await supabase.from('user_profiles').insert({ id: user.id, role: 'School Admin', full_name: data.adminName });
    
    // The rest of the school creation logic...
};

// --- INTEGRATIONS FUNCTIONS ---
// These are user-scoped but don't depend on school_id, instead on the user's own profile (e.g., a Super Admin's settings)
export const getGoogleAnalyticsConfig = async (): Promise<GoogleAnalyticsConfig | null> => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return null;
    const { data } = await supabase.from('google_analytics_config').select('*').eq('user_id', user.id).single();
    return data;
};
export const upsertGoogleAnalyticsConfig = async (config: Partial<Omit<GoogleAnalyticsConfig, 'id'>>) => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error("User must be logged in.");
    await supabase.from('google_analytics_config').upsert({ user_id: user.id, ...config }, { onConflict: 'user_id' });
};
export const getActiveGoogleAnalyticsConfig = async (): Promise<Pick<GoogleAnalyticsConfig, 'measurement_id'> | null> => {
    const { data } = await supabase.from('google_analytics_config').select('measurement_id').eq('is_enabled', true).limit(1).single();
    return data;
};

export const getCalendlyConfig = async (): Promise<CalendlyConfig | null> => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return null;
    const { data } = await supabase.from('calendly_config').select('*').eq('user_id', user.id).single();
    return data;
};
export const upsertCalendlyConfig = async (config: Partial<Omit<CalendlyConfig, 'id'>>) => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error("User must be logged in.");
    await supabase.from('calendly_config').upsert({ user_id: user.id, ...config }, { onConflict: 'user_id' });
};
export const getActiveCalendlyConfig = async (): Promise<Pick<CalendlyConfig, 'scheduling_link'> | null> => {
    const { data } = await supabase.from('calendly_config').select('scheduling_link').eq('is_enabled', true).limit(1).single();
    return data;
};

export const getPusherConfig = async (): Promise<PusherConfig | null> => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return null;
    const { data } = await supabase.from('pusher_config').select('*').eq('user_id', user.id).single();
    return data;
};
export const upsertPusherConfig = async (config: Partial<Omit<PusherConfig, 'id'>>) => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error("User must be logged in.");
    await supabase.from('pusher_config').upsert({ user_id: user.id, ...config }, { onConflict: 'user_id' });
};